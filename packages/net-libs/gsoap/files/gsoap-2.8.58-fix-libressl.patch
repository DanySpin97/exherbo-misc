Source: from FreeBSD, https://bugs.freebsd.org/bugzilla/show_bug.cgi?id=218375
Upstream: Not yet submitted
Reason: Fix build with LibreSSL

--- gsoap/VisualStudio2005/wsdl2h/wsdl2h/stdsoap2.cpp.orig	2017-04-07 18:39:02 UTC
+++ gsoap/VisualStudio2005/wsdl2h/wsdl2h/stdsoap2.cpp
@@ -3735,7 +3735,7 @@ ssl_auth_init(struct soap *soap)
   ERR_clear_error();
   if (!soap->ctx)
   {
-#if (OPENSSL_VERSION_NUMBER >= 0x10100000L)
+#if (OPENSSL_VERSION_NUMBER >= 0x10100000L && !defined(LIBRESSL_VERSION_NUMBER))
     /* TLS_method: a TLS/SSL connection established may understand the SSLv3, TLSv1, TLSv1.1 and TLSv1.2 protocols. */
     soap->ctx = SSL_CTX_new(TLS_method());
 #else
@@ -3812,7 +3812,7 @@ ssl_auth_init(struct soap *soap)
 #endif
   if ((soap->ssl_flags & SOAP_SSL_RSA))
   {
-#if (OPENSSL_VERSION_NUMBER >= 0x10100000L)
+#if (OPENSSL_VERSION_NUMBER >= 0x10100000L && !defined(LIBRESSL_VERSION_NUMBER))
     if (SSL_CTX_need_tmp_RSA(soap->ctx))
 #endif
     { RSA *rsa = RSA_generate_key(SOAP_SSL_RSA_BITS, RSA_F4, NULL, NULL);
@@ -5501,7 +5501,7 @@ tcp_disconnect(struct soap *soap)
             DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Connection lost...\n"));
             soap->fclosesocket(soap, soap->socket);
             soap->socket = SOAP_INVALID_SOCKET;
-#if (OPENSSL_VERSION_NUMBER >= 0x10100000L)
+#if (OPENSSL_VERSION_NUMBER >= 0x10100000L && !defined(LIBRESSL_VERSION_NUMBER))
             ERR_clear_error();
 #else
             ERR_remove_state(0);
@@ -5525,7 +5525,7 @@ tcp_disconnect(struct soap *soap)
     }
     SSL_free(soap->ssl);
     soap->ssl = NULL;
-#if (OPENSSL_VERSION_NUMBER >= 0x10100000L)
+#if (OPENSSL_VERSION_NUMBER >= 0x10100000L && !defined(LIBRESSL_VERSION_NUMBER))
     ERR_clear_error();
 #else
     ERR_remove_state(0);
@@ -6146,7 +6146,7 @@ soap_done(struct soap *soap)
       soap->ctx = NULL;
     }
   }
-#if (OPENSSL_VERSION_NUMBER >= 0x10100000L)
+#if (OPENSSL_VERSION_NUMBER >= 0x10100000L && !defined(LIBRESSL_VERSION_NUMBER))
   ERR_clear_error();
 #else
   ERR_remove_state(0);
--- gsoap/plugin/mecevp.c.orig	2017-04-07 18:39:01 UTC
+++ gsoap/plugin/mecevp.c
@@ -284,7 +284,7 @@ soap_mec_init(struct soap *soap, struct 
   int ok = 1;
   DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_mec_init()\n"));
   soap_ssl_init();
-#if (OPENSSL_VERSION_NUMBER < 0x10100000L)
+#if (OPENSSL_VERSION_NUMBER < 0x10100000L || defined(LIBRESSL_VERSION_NUMBER))
   data->ctx = (EVP_CIPHER_CTX*)SOAP_MALLOC(soap, sizeof(EVP_CIPHER_CTX));
   if (data->ctx)
     EVP_CIPHER_CTX_init(data->ctx);
@@ -448,7 +448,7 @@ soap_mec_cleanup(struct soap *soap, stru
   data->type = NULL;
   if (data->ctx)
   {
-#if (OPENSSL_VERSION_NUMBER < 0x10100000L)
+#if (OPENSSL_VERSION_NUMBER < 0x10100000L || defined(LIBRESSL_VERSION_NUMBER))
     EVP_CIPHER_CTX_cleanup(data->ctx);
     SOAP_FREE(soap, data->ctx);
 #else
--- gsoap/plugin/smdevp.c.orig	2017-04-07 18:39:01 UTC
+++ gsoap/plugin/smdevp.c
@@ -479,7 +479,7 @@ soap_smd_init(struct soap *soap, struct 
   /* allocate and init the OpenSSL HMAC or EVP_MD context */
   if ((alg & SOAP_SMD_ALGO) == SOAP_SMD_HMAC)
   {
-#if (OPENSSL_VERSION_NUMBER < 0x10100000L)
+#if (OPENSSL_VERSION_NUMBER < 0x10100000L || defined(LIBRESSL_VERSION_NUMBER))
     data->ctx = (void*)SOAP_MALLOC(soap, sizeof(HMAC_CTX));
     if (data->ctx)
       HMAC_CTX_init((HMAC_CTX*)data->ctx);
@@ -489,7 +489,7 @@ soap_smd_init(struct soap *soap, struct 
   }
   else
   {
-#if (OPENSSL_VERSION_NUMBER < 0x10100000L)
+#if (OPENSSL_VERSION_NUMBER < 0x10100000L || defined(LIBRESSL_VERSION_NUMBER))
     data->ctx = (void*)SOAP_MALLOC(soap, sizeof(EVP_MD_CTX));
     if (data->ctx)
       EVP_MD_CTX_init((EVP_MD_CTX*)data->ctx);
@@ -642,7 +642,7 @@ soap_smd_final(struct soap *soap, struct
       *len = (int)n;
   }
   /* cleanup */
-#if (OPENSSL_VERSION_NUMBER < 0x10100000L)
+#if (OPENSSL_VERSION_NUMBER < 0x10100000L || defined(LIBRESSL_VERSION_NUMBER))
   if ((data->alg & SOAP_SMD_ALGO) == SOAP_SMD_HMAC)
     HMAC_CTX_cleanup((HMAC_CTX*)data->ctx);
   else
@@ -687,7 +687,7 @@ soap_smd_check(struct soap *soap, struct
     }
     if (data->ctx)
     {
-#if (OPENSSL_VERSION_NUMBER < 0x10100000L)
+#if (OPENSSL_VERSION_NUMBER < 0x10100000L || defined(LIBRESSL_VERSION_NUMBER))
       if ((data->alg & SOAP_SMD_ALGO) == SOAP_SMD_HMAC)
         HMAC_CTX_cleanup((HMAC_CTX*)data->ctx);
       else
--- gsoap/samples/calc_vs2005/calc_vs2005/stdsoap2.cpp.orig	2017-04-07 18:39:02 UTC
+++ gsoap/samples/calc_vs2005/calc_vs2005/stdsoap2.cpp
@@ -3735,7 +3735,7 @@ ssl_auth_init(struct soap *soap)
   ERR_clear_error();
   if (!soap->ctx)
   {
-#if (OPENSSL_VERSION_NUMBER >= 0x10100000L)
+#if (OPENSSL_VERSION_NUMBER >= 0x10100000L && !defined(LIBRESSL_VERSION_NUMBER))
     /* TLS_method: a TLS/SSL connection established may understand the SSLv3, TLSv1, TLSv1.1 and TLSv1.2 protocols. */
     soap->ctx = SSL_CTX_new(TLS_method());
 #else
@@ -3812,7 +3812,7 @@ ssl_auth_init(struct soap *soap)
 #endif
   if ((soap->ssl_flags & SOAP_SSL_RSA))
   {
-#if (OPENSSL_VERSION_NUMBER >= 0x10100000L)
+#if (OPENSSL_VERSION_NUMBER >= 0x10100000L && !defined(LIBRESSL_VERSION_NUMBER))
     if (SSL_CTX_need_tmp_RSA(soap->ctx))
 #endif
     { RSA *rsa = RSA_generate_key(SOAP_SSL_RSA_BITS, RSA_F4, NULL, NULL);
@@ -5501,7 +5501,7 @@ tcp_disconnect(struct soap *soap)
             DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Connection lost...\n"));
             soap->fclosesocket(soap, soap->socket);
             soap->socket = SOAP_INVALID_SOCKET;
-#if (OPENSSL_VERSION_NUMBER >= 0x10100000L)
+#if (OPENSSL_VERSION_NUMBER >= 0x10100000L && !defined(LIBRESSL_VERSION_NUMBER))
             ERR_clear_error();
 #else
             ERR_remove_state(0);
@@ -5525,7 +5525,7 @@ tcp_disconnect(struct soap *soap)
     }
     SSL_free(soap->ssl);
     soap->ssl = NULL;
-#if (OPENSSL_VERSION_NUMBER >= 0x10100000L)
+#if (OPENSSL_VERSION_NUMBER >= 0x10100000L && !defined(LIBRESSL_VERSION_NUMBER))
     ERR_clear_error();
 #else
     ERR_remove_state(0);
@@ -6146,7 +6146,7 @@ soap_done(struct soap *soap)
       soap->ctx = NULL;
     }
   }
-#if (OPENSSL_VERSION_NUMBER >= 0x10100000L)
+#if (OPENSSL_VERSION_NUMBER >= 0x10100000L && !defined(LIBRESSL_VERSION_NUMBER))
   ERR_clear_error();
 #else
   ERR_remove_state(0);
--- gsoap/stdsoap2.c.orig	2017-04-07 18:39:02 UTC
+++ gsoap/stdsoap2.c
@@ -3735,7 +3735,7 @@ ssl_auth_init(struct soap *soap)
   ERR_clear_error();
   if (!soap->ctx)
   {
-#if (OPENSSL_VERSION_NUMBER >= 0x10100000L)
+#if (OPENSSL_VERSION_NUMBER >= 0x10100000L && !defined(LIBRESSL_VERSION_NUMBER))
     /* TLS_method: a TLS/SSL connection established may understand the SSLv3, TLSv1, TLSv1.1 and TLSv1.2 protocols. */
     soap->ctx = SSL_CTX_new(TLS_method());
 #else
@@ -3812,7 +3812,7 @@ ssl_auth_init(struct soap *soap)
 #endif
   if ((soap->ssl_flags & SOAP_SSL_RSA))
   {
-#if (OPENSSL_VERSION_NUMBER >= 0x10100000L)
+#if (OPENSSL_VERSION_NUMBER >= 0x10100000L && !defined(LIBRESSL_VERSION_NUMBER))
     if (SSL_CTX_need_tmp_RSA(soap->ctx))
 #endif
     { RSA *rsa = RSA_generate_key(SOAP_SSL_RSA_BITS, RSA_F4, NULL, NULL);
@@ -5501,7 +5501,7 @@ tcp_disconnect(struct soap *soap)
             DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Connection lost...\n"));
             soap->fclosesocket(soap, soap->socket);
             soap->socket = SOAP_INVALID_SOCKET;
-#if (OPENSSL_VERSION_NUMBER >= 0x10100000L)
+#if (OPENSSL_VERSION_NUMBER >= 0x10100000L && !defined(LIBRESSL_VERSION_NUMBER))
             ERR_clear_error();
 #else
             ERR_remove_state(0);
@@ -5525,7 +5525,7 @@ tcp_disconnect(struct soap *soap)
     }
     SSL_free(soap->ssl);
     soap->ssl = NULL;
-#if (OPENSSL_VERSION_NUMBER >= 0x10100000L)
+#if (OPENSSL_VERSION_NUMBER >= 0x10100000L && !defined(LIBRESSL_VERSION_NUMBER))
     ERR_clear_error();
 #else
     ERR_remove_state(0);
@@ -5703,6 +5703,9 @@ soap_bind(struct soap *soap, const char 
   }
 #endif
 #ifdef TCP_FASTOPEN
+       #ifndef SOL_TCP
+       #define SOL_TCP IPPROTO_TCP
+       #endif
   if (!(soap->omode & SOAP_IO_UDP) && setsockopt(soap->master, IPPROTO_TCP, TCP_FASTOPEN, (char*)&set, sizeof(int)))
   { /* silently ignore */
     DBGLOG(TEST, SOAP_MESSAGE(fdebug, "setsockopt TCP_FASTOPEN failed in soap_bind()\n"));
@@ -6146,7 +6149,7 @@ soap_done(struct soap *soap)
       soap->ctx = NULL;
     }
   }
-#if (OPENSSL_VERSION_NUMBER >= 0x10100000L)
+#if (OPENSSL_VERSION_NUMBER >= 0x10100000L && !defined(LIBRESSL_VERSION_NUMBER))
   ERR_clear_error();
 #else
   ERR_remove_state(0);
--- gsoap/stdsoap2.cpp.orig	2017-04-07 18:39:02 UTC
+++ gsoap/stdsoap2.cpp
@@ -3735,7 +3735,7 @@ ssl_auth_init(struct soap *soap)
   ERR_clear_error();
   if (!soap->ctx)
   {
-#if (OPENSSL_VERSION_NUMBER >= 0x10100000L)
+#if (OPENSSL_VERSION_NUMBER >= 0x10100000L && !defined(LIBRESSL_VERSION_NUMBER))
     /* TLS_method: a TLS/SSL connection established may understand the SSLv3, TLSv1, TLSv1.1 and TLSv1.2 protocols. */
     soap->ctx = SSL_CTX_new(TLS_method());
 #else
@@ -3812,7 +3812,7 @@ ssl_auth_init(struct soap *soap)
 #endif
   if ((soap->ssl_flags & SOAP_SSL_RSA))
   {
-#if (OPENSSL_VERSION_NUMBER >= 0x10100000L)
+#if (OPENSSL_VERSION_NUMBER >= 0x10100000L && !defined(LIBRESSL_VERSION_NUMBER))
     if (SSL_CTX_need_tmp_RSA(soap->ctx))
 #endif
     { RSA *rsa = RSA_generate_key(SOAP_SSL_RSA_BITS, RSA_F4, NULL, NULL);
@@ -5501,7 +5501,7 @@ tcp_disconnect(struct soap *soap)
             DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Connection lost...\n"));
             soap->fclosesocket(soap, soap->socket);
             soap->socket = SOAP_INVALID_SOCKET;
-#if (OPENSSL_VERSION_NUMBER >= 0x10100000L)
+#if (OPENSSL_VERSION_NUMBER >= 0x10100000L && !defined(LIBRESSL_VERSION_NUMBER))
             ERR_clear_error();
 #else
             ERR_remove_state(0);
@@ -5525,7 +5525,7 @@ tcp_disconnect(struct soap *soap)
     }
     SSL_free(soap->ssl);
     soap->ssl = NULL;
-#if (OPENSSL_VERSION_NUMBER >= 0x10100000L)
+#if (OPENSSL_VERSION_NUMBER >= 0x10100000L && !defined(LIBRESSL_VERSION_NUMBER))
     ERR_clear_error();
 #else
     ERR_remove_state(0);
@@ -5703,6 +5703,9 @@ soap_bind(struct soap *soap, const char 
   }
 #endif
 #ifdef TCP_FASTOPEN
+       #ifndef SOL_TCP
+       #define SOL_TCP IPPROTO_TCP
+       #endif
   if (!(soap->omode & SOAP_IO_UDP) && setsockopt(soap->master, IPPROTO_TCP, TCP_FASTOPEN, (char*)&set, sizeof(int)))
   { /* silently ignore */
     DBGLOG(TEST, SOAP_MESSAGE(fdebug, "setsockopt TCP_FASTOPEN failed in soap_bind()\n"));
@@ -6146,7 +6149,7 @@ soap_done(struct soap *soap)
       soap->ctx = NULL;
     }
   }
-#if (OPENSSL_VERSION_NUMBER >= 0x10100000L)
+#if (OPENSSL_VERSION_NUMBER >= 0x10100000L && !defined(LIBRESSL_VERSION_NUMBER))
   ERR_clear_error();
 #else
   ERR_remove_state(0);
